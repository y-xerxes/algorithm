# 树

<script type="text/x-mathjax-config">
MathJax.Hub.Config({tex2jax: {inlineMath:[['$','$']]}});
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
----

## 树的基本概念
树中的一个节点的子节点的个数称这个**节点的度**，树中节点的最大度数称为**树的度**。

**节点的深度**是从根节点开始自顶向下逐层累加。

**节点的高度**是从叶节点开始自底向上逐层累加的。

**树的高度（深度）**是树中节点的最大层数。

----

## 二叉树

每个节点至多只有两颗子树，节点有左右之分，是一颗有序树。

### 性质

- 二叉树的第i层最多有$2^{i-1}$个节点
- 深度为k的二叉树最多有$2^k - 1$个节点
- 对于任意一棵二叉树，如果其叶子节点数为$n_0$，度为2的节点数为$n_2$，则$n_0 = n_2 + 1$

### 满二叉树

一棵深度为k并且有$2^k - 1$个节点的二叉树称为满二叉树。其深度为$log_2^n + 1$。

满二叉树的所有非叶子节点都存在左右字节点，并且所有叶子节点都在同一层。即满二叉树的每一个分支都是满的。

### 完全二叉树

对一个有n 个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n 的节点位置相同，则这个二叉树为完全二叉树。

### 二叉查找树

- 如果左子树不为空，则左子树上所有结点的值均小于或等于它的根结点的值
- 如果右子树不为空，则右子树上所有结点的值均大于或等于它的根结点的值
- 左、右子树也分别为二叉查找树

### 平衡二叉树（AVL Tree）

平衡二叉树在符合二叉查找树的条件下，还满足任何节点的两个子树的高度相差不超过1。
如果在AVL树中进行插入或删除节点，可能导致AVL树失去平衡，这种失去平衡的二叉树可以概括为自种姿态：LL、RR、LR、RL。四种姿态的定义为：插入或删除一个节点后，根节点的左/右子节点的左/右子节点还有非空节点，导致根节点的左/右子树比左/右子树的高度高2。
AVL树失去平衡后，可以通过旋转使其恢复平衡。
以LL旋转为例：

1. 将根节点的左孩子作为新根节点。
2. 将新根节点的右孩子作为原根节点的左孩子。
3. 将原根节点作为新根节点的右孩子。
![](/Users/xerxes/Development/algorithm/resources/LL单旋转.png)

----

## 树的存储方式

二叉树属于逻辑结构，可以通过**链式存储结构**和**数组**两种物理结构存储。

### 链式存储结构

![](/Users/xerxes/Development/algorithm/resources/链式存储结构存储树.png)

二叉树每个节点包含3部分：

- 存储数据的data 变量；
- 指向左孩子的left 指针；
- 指向右孩子的right 指针

### 数组存储结构

![](/Users/xerxes/Development/algorithm/resources/数组存储结构存储树.png)

使用数组存储时，会按照层级顺序把二叉树的节点放到数组中对应的位置上。如果某一个节点的左孩子或右孩子空缺，则数组相应位置也空出来。

之所以这样设计，是为了更方便地在数组中定位二叉树的孩子节点和父节点。

假设一个父节点的下标是parent，则左孩子节点下标就是`2 \* parent + 1`，右孩子节点下标就是`2 \* parent + 2`。

----

## 二叉树的应用

二叉树包含许多特殊的形式，每一种形式都有自己的作用，但是其最主要的应用还在于进行**查找操作**和**维持相对顺序**两个方面。

### 查找

比如二叉查找树的作用就是查找，对于一个节点分布相对均衡的二叉查找树来说，如果节点总数是n，那么搜索节点的时间复杂度就是`O(logn)`，和树的深度是一样的。

这种依靠比较大小来逐步查找的方式，和二分查找算法非常相似。

### 维持相对顺序

依然以二叉查找树为例，二叉查找树要求左子树小于父节点，右子树大于父节点，正是这样保证了二叉树的有序性。因此二叉查找树也被称为二叉排序树。

----

## 二叉树的遍历

从节点之间位置关系角度来看，二叉树的遍历分为4种：

- 前序遍历
- 中序遍历
- 后序遍历
- 层序遍历

从更宏观的角度来看，二叉树的遍历归结为两大类：

- 深度优先遍历（前序、中序、后序）
- 广度优先遍历（层序）

深度优先和广度优先这两个概念不只局限于二叉树，它们更是一种抽象的算法思想，决定了访问某些复杂数据结构的顺序。

### 深度优先遍历

#### 前序遍历

二叉树的前序遍历，输出顺序是根节点、左子树、右子树。

![](/Users/xerxes/Development/algorithm/resources/二叉树的前序遍历.png)

#### 中序遍历

二叉树的中序遍历，输出顺序是左子树、根节点、右子树。

![](/Users/xerxes/Development/algorithm/resources/二叉树的中序遍历.png)

#### 后序遍历

二叉树的后序遍历，输出顺序是左子树、右子树、根节点。

![](/Users/xerxes/Development/algorithm/resources/二叉树的后序遍历.png)

