# LSM树（Log-structured Merge-tree）
**LSM 树的本质是将大量的随机写操作转换成批量的顺序写**，这样可以极大地提升磁盘数据写入速度，所以LSM 树非常适合对写操作效率有高要求的应用场景。但是读效率不高，一般可以引入Bloom Filter 或者缓存等优化措施来对读性能进行改善。
----
## 诞生背景
传统数据库一般使用B-Tree或者一些变体作为存储结构，但保存在磁盘中时，逻辑上相离很近的数据物理上可能离得很远，造成大量随机读写。
为了提升I/O性能，需要一种能将随机操作变为顺序操作的机制，就有了LSM树。
----
## 原理
LSM 树将对数据的修改增量地保存在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘。读的时候需要合并磁盘中历史数据和内存中最近修改操作。

LSM树由两个或两个以上的存储结构组成。
一个存储结构常驻内存中，称为C0 tree，具体可以是任何方便健值查找的数据结构，比如红黑树、map之类，甚至可以是跳表。
另外一个存储结构常驻在硬盘中，称为C1 tree，具体结构类似B树。C1所有节点都是100%满的，节点的大小为磁盘块大小。
![](/Users/xerxes/Development/algorithm/resources/LSM%E6%A0%91%E5%8E%9F%E7%90%86.jpg)
简单的说，LSM树原理就是把一棵大树拆分成n棵小树，首先写入内存，随着小树越来越大，内存中的小树批量flush到磁盘中独立的文件中以提高I/O性能，而为了提高读性能磁盘中的树可以定期做merge操作，合并成一棵大树。

----
## 插入流程
插入一条新记录时，首先在日志文件中插入操作日志，以便后续恢复，日志以append形式插入，所以速度非常快；
将新记录的索引插入到C0中，这里在内存中完成，不涉及磁盘I/O；
当C0大小达到某一阈值或者每隔一段时间，将C0中记录滚动合并到C1中；
对于多个存储结构的情况，当C1体量越来越大就向C2合并，以此类推。
----
## 合并流程
合并过程会使用两个块：emptying block和filling block。
1. 从C1中读取未合并叶子节点，放置内存中的emptying block中；
2. 从小到大找C0中的节点，与emptying block进行合并排序，合并结果保存到filling block中，并将C0对应的节点删除；
3. 不断执行第二步，合并排序结果不断填入filling block中，filling block满了就追加到磁盘的新位置上。合并期间如果emptying block使用完了就重新从C1中读取未合并的叶子节点；
4. C0和C1所有叶子节点都按以上合并完成后即完成一次合并